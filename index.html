<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <style>
            body {
                padding: 0 0;
                background-color: black;
                color: white;
            }
            #c {
                width: 20vh;
                height: 90vh;
                display: block;
                float: left;
                image-rendering: optimizeSpeed;
            }
            #editor {
                width: 80vw;
                height: 90vh;
                background-color: black;
                border: none;
                color: white;
                padding: 5px;
            }
        </style>
        <script id="2d-vertex-shader" type="notjs">

        // an attribute will receive data from a buffer
        attribute vec4 a_position;

        // all shaders have a main function
        void main() {
          // gl_Position is a special variable a vertex shader
          // is responsible for setting
          gl_Position = a_position;
        }

        </script>
        <script id="fragment-shader-preamble" type="notjs">
        // fragment shaders don't have a default precision so we need
        // to pick one. mediump is a good default
        precision mediump float;

        float hue2rgb(float f1, float f2, float hue) {
            if (hue < 0.0)
                hue += 1.0;
            else if (hue > 1.0)
                hue -= 1.0;
            float res;
            if ((6.0 * hue) < 1.0)
                res = f1 + (f2 - f1) * 6.0 * hue;
            else if ((2.0 * hue) < 1.0)
                res = f2;
            else if ((3.0 * hue) < 2.0)
                res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
            else
                res = f1;
            return res;
        }

        vec3 hsl2rgb(vec3 hsl) {
            vec3 rgb;
            
            if (hsl.y == 0.0) {
                rgb = vec3(hsl.z); // Luminance
            } else {
                float f2;
                
                if (hsl.z < 0.5)
                    f2 = hsl.z * (1.0 + hsl.y);
                else
                    f2 = hsl.z + hsl.y - hsl.y * hsl.z;
                    
                float f1 = 2.0 * hsl.z - f2;
                
                rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
                rgb.g = hue2rgb(f1, f2, hsl.x);
                rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
            }
            return rgb;
        }

        vec3 hsl2rgb(float h, float s, float l) {
            return hsl2rgb(vec3(h, s, l));
        }

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
    </script>
    </head>
    <body>
        <div id="topbar">
            <button onclick="live_renderer.reloadShader()">Play</button>
            <button onclick="save()">Render and Download</button>
            <span id="status">ready</span>
        </div>
        <canvas id="c" height="12" width="191"></canvas>
<div id="editor">// time is a float between 0.0 and 10.0, representing the current time in seconds
// the animation loops every 10 seconds
uniform float time;

// WARNING: This editor does not currently save any of your progress
// COPY AND PASTE TO ANOTHER EDITOR TO SAVE (for now)

// If you make a cool animation, please give it a good filename.json and mail
// it to shaders (Ã¤t) notafile.com

void main() {
    // the warpcore resolution is 12x191 pixel
    // the canvas coordinates go from -1 to 1, with 0 in the middle

    // This function gets 'called' for each pixel in the image
    // set constants using const. Almost everything is a float,
    // don't forget to add the .0 at the end, else stuff breaks
    const float x_scale = 6.0;
    const float y_scale = 100.0;
    const float time_scaler = 20.0;

    // use gl_FragCoord to access the current coordinate
    float hue_1 = (gl_FragCoord.y + time * time_scaler) / x_scale;
    float hue_2 = gl_FragCoord.x / y_scale;
    vec3 rgb = hsl2rgb(mod(hue_1 + hue_2, 12.0) / 12.0, 1.0, 0.5);
    // gl_FragColor is a special variable in a fragment shader
    // it is responsible for setting the color of the pixel
    gl_FragColor = vec4(rgb, 1.0);
}

// a number of functions have already been defined:
// -- hsv
// vec3 hsv2rgb(h, s, v)
// vec3 hsv2rgb(vec3)
// -- random
// float rand(vec2) // vec2 is the seed
</div>
        <a id="dllink" target="_blank" download="animation.json"></a>
        <script src="ace-builds/src-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="index.js"></script>
    </body>
</html>
